EXTENTION chess-0.9-1
# $Id: chess.ext.beta,v 1.1 2001-07-25 15:32:14 uri Exp $

namespace eval chess {
    variable colors
    set colors(p0) cyan
    set colors(p1) red
    set colors(s0) white
    set colors(s1) black
    set colors(phi) yellow

    proc init {} {
	iface_init
	canvas_init
    }
    
    proc destroy {} {
	destroy_widget .chess
	namespace delete [namespace current]
    }

    proc iface_init {} {
	toplevel .chess
	wm title .chess "XCchess"
	wm protocol .chess WM_DELETE_WINDOW [namespace current]::window_close
	wm withdraw .chess
    }
        
    proc canvas_init {} {
	canvas .chess.canvas -relief raised -border 2 -height [expr 32 * 8] -width [expr 32 * 8] -background gray
	grid configure .chess.canvas -row 1 -column 1
	draw_board 32 32
    }

    proc get_square_coords {h v} {
	variable board
	return [list	\
	    [expr $board(hoffs) + $h * $board(hsize)]	\
	    [expr $board(voffs) + $v * $board(vsize)]	\
	    [expr $board(hoffs) + $h * $board(hsize) + $board(hsize) - 1]\
	    [expr $board(voffs) + $v * $board(vsize) + $board(vsize) - 1]]
    }
    
    proc get_square_by_coords {x y} {
	variable board
	return [list \
	    [expr ($x - $board(hoffs)) / $board(hsize)] \
	    [expr ($y - $board(voffs)) / $board(vsize)]]
    }
    
    proc get_piece_coords {h v} {
	set coords [get_square_coords $h $v]
	return [list \
	    [expr [lindex $coords 0] + 2] \
	    [expr [lindex $coords 1] + 2] \
	    [expr [lindex $coords 2] - 2] \
	    [expr [lindex $coords 3] - 2]]
    }
    
    proc format_coords {coords} {
	set letters "ABCDEFGH"
	return [string index $letters [lindex $coords 0]][expr [lindex $coords 1] + 1]
    }

    proc draw_piece {h v piece color} {
	set ucoords [get_piece_coords $h $v]
	set oval [eval .chess.canvas create oval $ucoords {-fill $color -outline $color -stipple gray50}]
	set textx [expr ([lindex $ucoords 0] + [lindex $ucoords 2]) / 2]
	set texty [expr ([lindex $ucoords 1] + [lindex $ucoords 3]) / 2]
	set text [.chess.canvas create text $textx $texty [string range $piece 0 1]]
	return 
    }
    
    proc draw_board {{hsize 0} {vsize 0} {hoffs 0} {voffs 0}} {
	variable board
	variable colors
	if !$hsize {
	    set hsize [expr [.drawing_canvas.canvas cget -height] / 8]
	    set hoffs [expr [.drawing_canvas.canvas cget -height] % 8 / 2]
	}
	if !$vsize {
	    set vsize [expr [.drawing_canvas.canvas cget -width] / 8]
	    set voffs [expr [.drawing_canvas.canvas cget -width] % 8 / 2]
	}
	incr hoffs 2
	incr voffs 2
	set board(hsize) $hsize
	set board(vsize) $vsize
	set board(hoffs) $hoffs
	set board(voffs) $voffs
	set color 1
	for {set h 0} {$h < 8} {incr h} {
	    for {set v 0} {$v < 8} {incr v} {
		.chess.canvas delete square$h$v
		set item [eval .chess.canvas create rectangle [get_square_coords $h $v] {-fill $colors(s$color) -outline $colors(s$color)}]
		.chess.canvas addtag square$h$v withtag $item
		.chess.canvas lower $item
		set color [expr !$color]
	    }
	    set color [expr !$color]
	}
    }
    
    proc init_game {} {
	variable board
	variable colors
	variable game
	wm deiconify .chess
	set game(p0) 12
	set game(p1) 12
	set game(pactive) [expr $game(network) && $game(isblack)]
	foreach v {0 1 2 5 6 7} player {1 1 1 0 0 0} {
	    for {set h [expr $v % 2]} {$h < 8} {incr h 2} {
		if {$game(network) && $game(isblack)} {
		    set piece [draw_piece $h $v $colors(p[expr !$player])]
		} else {
		    set piece [draw_piece $h $v $colors(p$player)]
		}
		set board(sq$h$v) $piece
		set board(u$piece) $player
		.chess.canvas addtag pieces withtag $piece
	    }
	}
	.chess.canvas bind pieces <Any-Enter> [namespace current]::piece_enter
	.chess.canvas bind pieces <Any-Leave> [namespace current]::piece_leave
	.chess.canvas bind pieces <ButtonPress-1> "[namespace current]::piece_bpress %x %y"
	.chess.canvas bind pieces <ButtonRelease-1> "[namespace current]::piece_brelease %x %y %s"
	.chess.canvas bind pieces <B1-Motion> "[namespace current]::piece_bmotion %x %y"
    }
    
    proc finish_game {} {
	variable board
	variable game
	.chess.canvas delete pieces
	foreach i [concat [array names board sq*] [array names board qu*] \
		  [array names board u*]] {
	    unset board($i)
	}
	foreach i [concat [array names game p*] network isblack] {
	    unset game($i)
	}
	wm withdraw .chess
    }
    
    proc game_win {player} {
	variable game
	if $game(network) {
	    if $player {
		putcmsg xcplus_chess_youlost p $game(peer)
		tk_dialog .chess.dialog "You lost !" "You lost the game :-(" info 0 "Bummer !"
	    } else {
		putcmsg xcplus_chess_youwon p $game(peer)
		tk_dialog .chess.dialog "You won !" "You won the game !" info 0 "Yey !"
	    }
	} else {
	    set name [expr {$player ? "black" : "white"}]
	    putcmsg xcplus_chess_win t $name
	    if [tk_dialog .chess.dialog "The $name won !" "The $name player won the game !" info 1 "Dismiss" "Another Game !"] {
		set new_game 1
	    }
	}
	finish_game
	if [info exists new_game] {
	    set game(network) 0
	    set game(isblack) 0
	    init_game
	}
    }
    
    proc is_piece {coords} {
	variable board
	return [info exists board(sq[join $coords ""])]
    }
    
    proc get_piece {coords} {
	variable board
	if [info exists board(sq[join $coords ""])] {
	    return $board(u$board(sq[join $coords ""]))
	} else {
	    return ""
	}
    }

    proc destroy_piece {coords player} {
	variable board
	variable game
	set piece $board(sq[join $coords ""])
	unset board(sq[join $coords ""])
	.chess.canvas delete $piece
	incr game(p$player) -1
	if !$game(p$player) {
	    after idle {game_win [expr !$player]}
	}
    }
    
    proc is_queen {piece} {
	variable board
	return [info exists board(qu$piece)]
    }
    
    proc make_queen {piece} {
	variable board
	set board(qu$piece) 1
	.chess.canvas itemconfigure $piece -stipple ""
    }
    
    proc piece_move {piece source target} {
	variable board
	unset board(sq[join $source ""])
	set board(sq[join $target ""]) $piece
    }
    
    proc can_move {piece type source target player} {
	if {$source == $target} {
	    return 0
	}
	if {[get_piece $target] == $player} {
	    return 0
	}
	set sx [lindex $source 0]
	set sy [lindex $source 1]
	set tx [lindex $target 0]
	set ty [lindex $target 1]
	switch $type {
	    pawn {
	    }
	    knight {
		if {abs($tx - $sx) + abs($ty - $sy) == 3 && $tx != $sx &&
		    $ty != $sy} {
		    return 1
		}
	    }
	    bishop {
		if {abs($tx - $sx) == abs($ty - $sy)} {
		    return 1
		}
	    }
	    rook {
		if {$tx == $sx || $ty == $sy} {
		    return 1
		}
	    }
	    queen {
		if {abs($tx - $sx) == abs($ty - $sy) || $tx == $sx || $ty == $sy} {
		    return 1
		}
	    }
	    king {
		if {(abs($tx - $sx) < 2 && abs($ty - $sy < 2)) || 
		    [can_castle $source $target]} {
		    if ![can_piece_be_eaten $target] {
			
		    }
		}
	    }
	}
	return 0
    }
    
    proc move_piece {piece source target player with_multi} {
	variable board
	variable game
	set multi [info exists game(inmulti)]
	if $multi {
	    unset game(inmulti)
	}
	switch -- [can_move $piece $source $target $player $multi] {
	    0 {
		return 0
	    }
	    1 {
		set multi 0
	    }
	    2 {
		if $with_multi {
		    set game(inmulti) 1
		    set multi 1
		} else {
		    set multi 0
		}
	    }
	}
	# check - should item turn into queen ?
	if {[lindex $target 1] == ($player ? 7 : 0)} {
	    make_queen $piece
	}
	piece_move $piece $source $target
	if !$multi {
	    set game(pactive) [expr !$game(pactive)]
	}
	return [expr $multi ? 2 : 1]
    }
    
    proc piece_enter {} {
	variable colors
	.chess.canvas itemconfigure current -fill $colors(phi) -outline $colors(phi)
    }
    
    proc piece_leave {} {
	variable colors
	variable board
	variable game
	set curpiece [.chess.canvas find withtag current]
	if {$game(isblack)} {
	    set color $colors(p[expr !$board(u$curpiece)])
	} else {
	    set color $colors(p$board(u$curpiece))
	}
	.chess.canvas itemconfigure current -fill $color -outline $color
    }

    proc piece_bpress {x y} {
	variable current_piece
	variable board
	variable game
	set piece [.chess.canvas find withtag current]
	if {$game(pactive) != $board(u$piece) ||
	    ($game(pactive) == 1 && $game(network))} {
	    bell
	    return
	}
	set current_piece(name) $piece
	set current_piece(coords) [get_square_by_coords $x $y]
	set ucoords [.chess.canvas coords current]
	set board(hfix) [expr $x - [lindex $ucoords 0]]
	set board(vfix) [expr $y - [lindex $ucoords 1]]
    }
    
    proc piece_bmotion {x y} {
	variable current_piece
	variable board
	if ![info exists current_piece] {
	    return
	}
	set x [expr $x - $board(hfix)]
	set y [expr $y - $board(vfix)]
	.chess.canvas coords $current_piece(name) $x $y [expr $x + $board(hsize) - 4] [expr $y + $board(vsize) - 4]
    }

    proc piece_brelease {x y state} {
	variable current_piece
	variable board
	variable game
	set with_multi [expr $state & 0x1]
	if ![info exists current_piece] {
	    return
	}
	set square [get_square_by_coords $x $y]
	if {$square == $current_piece(name)} {
	    eval .chess.canvas coords $current_piece(name) [eval get_piece_coords $current_piece(coords)]
	    return
	}
	if [set ret [move_piece $current_piece(name) $current_piece(coords) $square $board(u$current_piece(name)) $with_multi]] {
	    eval .chess.canvas coords $current_piece(name) [eval get_piece_coords $square]
	    if $game(network) {
		if {$ret == 1} {
		    putsock "CMD $game(peer) CKRS MOVE [format_coords $current_piece(coords)] [format_coords $square]"
		} else {
		    putsock "CMD $game(peer) CKRS MULTI MOVE [format_coords $current_piece(coords)] [format_coords $square]"
		}
	    }
	} else {
	    eval .chess.canvas coords $current_piece(name) [eval get_piece_coords $current_piece(coords)]
	    bell
	}
	unset current_piece
    }
    
    proc process_peer_move {source target ismulti} {
	variable board
	set h [expr 7 - [lindex $source 0]]
	set v [expr 7 - [lindex $source 1]]
	set source [list $h $v]
	set target [list [expr 7 - [lindex $target 0]] [expr 7 - [lindex $target 1]]]
	if ![info exists board(sq$h$v)] {
	    return 0
	}
	set piece $board(sq$h$v)
	if [move_piece $piece $source $target 1 $ismulti] {
	    eval .chess.canvas coords $piece [eval get_piece_coords $target]
	    return 1
	}
	return 0
    }

    proc window_close {} {
	variable game
	if [info exists game(peer)] {
	    putsock "CMD $game(peer) CKRS CANCEL"
	}
	finish_game
    }

    proc server_error {sargs} {
	variable game
	set errornum [strtok sargs]
	if {$errornum == 104} {
	    set nick [string tolower [strtok sargs]]
	    if [info exists game(network)] {
		if {$nick == $game(peer)} {
		    putcmsg xcplus_chess_disc p $game(peer)
		    tk_dialog .chess.dialog "Remote side disconnected." "The remote side disconnected." error 0 "Bummer !"
		    finish_game
		}
	    }
	    foreach i [array names game *,$nick] {
		unset game($i)
	    }
	}
	return 0
    }

    proc ucmd_chess {uargs} {
	variable game
	set peer [strtok uargs]
	set lpeer [string tolower $peer]
	if {[string toupper $peer] == "REFUSE"} {
	    set peer [strtok uargs]
	    set reason [strrest uargs]
	    if {$peer == ""} {
		return 1
	    }
	    if [info exists game(offers,$lpeer)] {
		unset game(offers,$lpeer)
		putcmsg xcplus_chess_refusing n $peer t $reason
		putsock "CMD $peer CKFS refuse $reason"
	    } else {
		putcmsg xcplus_chess_norefuse n $peer
	    }
	    return 1
	}
	if {[string toupper $peer] == "PLAY"} {
	    set peer [strtok uargs]
	}
	if [info exists game(network)] {
	    putcmsg xcplus_chess_inprogress
	    return 1
	}
	if {$peer == ""} {
	    set game(network) 0
	    set game(isblack) 0
	    init_game
	    return 1
	}
	if [info exists game(offers,$lpeer)] {
	    unset game(offers,$lpeer)
	    set game(network) 1
	    set game(isblack) 1
	    set game(peer) $lpeer
	    putcmsg xcplus_chess_start n $peer
	    init_game
	    putsock "CMD $peer CKRS START"
	    return 1
	}
        set game(offerto,$lpeer) 1
        putsock "CMD $peer CKRS PLAY"
	putcmsg xcplus_chess_offering n $peer
	return 1
    }
    
    proc server_cmd_ckrs {source cargs} {
	variable game
	set cargs [split $cargs]
	set cmd [strtok cargs]
	set lsource [string tolower $source]
	set multi 0
	if {[string toupper $cmd] == "MULTI"} {
	    set multi 1
	    set cmd [strtok cargs]
	}
	switch -exact -- [string toupper $cmd] {
	    PLAY {
		set game(offers,$lsource) 1
		putcmsg xcplus_chess_offer n $source
	    }
	    START {
		if [info exists game(network)] {
		    putsock "CMD $source REFUSE Game already in progress."
		}
		if [info exists game(offerto,$lsource)] {
		    unset game(offerto,$lsource)
		    set game(isblack) 0
		    set game(network) 1
		    set game(peer) $lsource
		    putcmsg xcplus_chess_start n $source
		    init_game
		} else {
		    putsock "CMD $source REFUSE I didn't offer you any game."
		}
	    }
	    CANCEL {
	        if [info exists game(network)] {
		    if {$lsource == $game(peer)} {
			putcmsg xcplus_chess_disc p $game(peer)
			tk_dialog .chess.dialog "Remote side disconnected." "The other player left the game." error 0 "Bummer !"
			finish_game
		    }
		}
	    }
	    REFUSE {
		set reason [strrest $cargs]
		putcmsg xcplus_chess_refuse n $source t $reason
	    }
	    MOVE {
		if ![info exists game(peer)] {
		    return 1
		}
		if {$game(peer) != $lsource} {
		    return 1
		}
		if !$game(pactive) {
		    putcmsg xcplus_chess_turncheat n $source
		    return 1
		}
		set letters "ABCDEFGH"
		set src [strtok cargs]
		set target [strtok cargs]
		if {[string length $src] != 2 || [string length $target] != 2} {
		    putcmsg xcplus_chess_badmove n $source
		    return 1
		}
		set num 0
		foreach {i j} [split $src$target ""] {
		    set i [string toupper $i]
		    if {![string match {[ABCDEFGH]} $i] || ![string match {[12345678]} $j]} {
			putcmsg xcplus_chess_badmove n $source
			return 1
		    }
		    set coords($num) [list [expr [string first $i $letters]] [expr $j - 1]]
		    incr num
		}
		if ![process_peer_move $coords(0) $coords(1) $multi] {
		    putcmsg xcplus_chess_cheatmove n $source
		}
	    }
	}
	return 1
    }
    
}
